<!DOCTYPE html>
<title>Digital Identity Credential tests.</title>
<link rel="help" href="https://wicg.github.io/digital-identities/">
<script src="/common/get-host-info.sub.js"></script>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-vendor.js"></script>

<body>
  <iframe id="same-origin"></iframe>
  <iframe id="cross-origin"></iframe>
<script type="module">
import { buildValidNavigatorIdentityRequest, buildValidNavigatorIdentityRequestWithRequestObject, loadIframe, requestIdentityWithActivation, sendMessage } from '/wpt_internal/digital-credentials/support/helper.js';

const iframeSameOrigin = document.querySelector("iframe#same-origin");
const iframeCrossOrigin = document.querySelector("iframe#cross-origin");

promise_setup(async () => {
  const hostInfo = get_host_info();
  await Promise.all([
    loadIframe(
      iframeCrossOrigin,
      `${hostInfo.HTTPS_REMOTE_ORIGIN}/wpt_internal/digital-credentials/support/iframe.html`
    ),
    loadIframe(iframeSameOrigin, "/wpt_internal/digital-credentials/support/iframe.html"),
  ]);
});

// Tests for success are here because the tests rely on the
// --use-fake-ui-for-digital-identity command line flag. Moving the tests to
// /external requires a WebDriver testing API.

promise_test(async t => {
  let request = buildValidNavigatorIdentityRequest();
  let credential = await requestIdentityWithActivation(test_driver, request);
  assert_equals("urn:openid.net:oid4vp", credential.protocol);
  assert_equals("fake_test_token", credential.data);
}, "navigator.identity.get() API works in toplevel frame.");

promise_test(async t => {
  const request = buildValidNavigatorIdentityRequestWithRequestObject();
  let credential = await requestIdentityWithActivation(test_driver, request);
  assert_equals("urn:openid.net:oid4vp", credential.protocol);
  assert_equals("fake_test_token", credential.data);
}, "navigator.identity.get() API succeeds when IdentityRequestProvider#request is an object instead of stringified JSON object");

promise_test(async t=> {
  let abortController = new AbortController();
  let request = buildValidNavigatorIdentityRequest();
  request.signal = abortController.signal;
  let requestPromise = requestIdentityWithActivation(test_driver, request);
  abortController.abort();
  await promise_rejects_dom(t, "AbortError", requestPromise);
}, "navigator.identity.get() promise is rejected when the page aborts the request.");

promise_test(async t=> {
  const result = await sendMessage(iframeSameOrigin);
  assert_equals(result.constructor, "DigitalCredential");
  assert_equals(result.data, "fake_test_token");
}, "navigator.identity.get() succeeds in same-origin iframe");

// Internal test because the spec does not have a 1 provider limit.
promise_test(async t => {
  let request = buildValidNavigatorIdentityRequest();
  let providerCopy = structuredClone(request.digital.providers[0]);
  request.digital.providers.push(providerCopy);
  await promise_rejects_js(t, TypeError, requestIdentityWithActivation(test_driver, request));
}, "navigator.identity.get() API fails if there is more than one provider.");

// Internal test because this test is more of an integration test. The spec does
// not define the behavior if the passed-in request object is super big.
promise_test(async t => {
  const request = buildValidNavigatorIdentityRequestWithRequestObject();
  const largeList = [];
  for (let i = 0; i < 1000000; ++i) {
    largeList.push("Value " + i);
  }
  request.digital.providers[0].request.random = largeList;
  await promise_rejects_js(t, TypeError, requestIdentityWithActivation(test_driver, request));
}, "navigator.identity.get() API fails when IdentityRequestProvider#request object is too big");

</script>
